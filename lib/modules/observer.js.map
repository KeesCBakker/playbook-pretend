{"version":3,"sources":["../../src/modules/observer.js"],"names":["constructor","arrayToObserve","observers","proxy","ObservedArray","Array","clone","slice","push","prototype","apply","arguments","arg","map","cb","id","call","observed","el","index","get","observe","uniqueId","unobserve","unobserveAll","next","Promise","resolve","reject","value","state","count","find","needle","args","limit","isInteger","shift","iterator","isFunction","found","isEqual","maxed","match","regex","join","all","Error"],"mappings":"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","file":"observer.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\n\n/**\n * Let tests observe additions to an array (of messages) via helper methods:\n * - `.next` - Watch for the next new element\n * - `.find` - Fidn a specific element\n * - `.match` - Find element matching a pattern\n * - `.all` - Do something with every element\n *\n * Each return an object with result attributes:\n * - _value_ - the last observed value when conditions were met\n * - _state_ - the state of the observed when the conditions were met\n * - _count_ - the number of additions between first call and a result\n *\n * `find`, `match` and `all` accept a _limit_ (int) of additions to observe, as\n * well as an _iterator_ (function) to call with every addition.\n *\n * With `find` and `match`, if limit is reached before main condition met\n * _value_ will be null\n */\nexport default class {\n  /**\n   * Get observer for array (this.observed should replace the original)\n   * @param  {array} arrayToObserve Array to observe\n   * @return {Observer}             Observer containing observed array\n   */\n  constructor (arrayToObserve = null) {\n    this.observers = {}\n    if (arrayToObserve != null) this.proxy(arrayToObserve)\n  }\n\n  /**\n   * Proxy the array, call observers to when setting a value.\n   *\n   * Callbacks are passed an array with the value and the current array state.\n   *\n   * Applies only on push calls, not direct propterty sets.\n   *\n   * @param  {array} arrayToObserve Array to observe\n   * @return {array}                Observed (proxy) array\n   */\n  proxy (arrayToObserve) {\n    let observers = this.observers\n\n    class ObservedArray extends Array {\n      clone () {\n        return this.slice(0)\n      }\n      push () {\n        Array.prototype.push.apply(this, arguments)\n        for (let arg of arguments) {\n          _.map(observers, (cb, id) => {\n            cb.call(this, arg, this.clone(), id)\n          })\n        }\n        return true\n      }\n    }\n    let observed = new ObservedArray()\n    arrayToObserve.map((el, index) => {\n      observed[index] = el // copy over any existing values\n    })\n    this.observed = arrayToObserve = observed\n    /*\n    this.observed = new Proxy(arrayToObserve, {\n      set: function (target, property, value, receiver) {\n        target[property] = value\n        if (Number.isInteger(parseInt(property))) {\n          _.map(observers, (cb, id) => {\n            cb.call(this, value, _.clone(target), id)\n          })\n        }\n        return true\n      }\n    })\n    */\n    return this.observed\n  }\n\n  /**\n   * Get the observed array\n   * @return {array} Observed (proxy) array\n   */\n  get () {\n    return this.observed\n  }\n\n  /**\n   * Add a callback to call with any addition to observed array\n   * @param  {Function} cb Callback, given new value as argument\n   * @return {string}      ID of callback in observer collection (for removing)\n   */\n  observe (cb) {\n    let id = _.uniqueId('observer_')\n    this.observers[id] = cb\n    return id\n  }\n\n  /**\n   * Remove a callback from observer collection\n   * @param  {string} index ID of callback to remove\n   */\n  unobserve (index) {\n    if (index in this.observers) delete this.observers[index]\n  }\n\n  /**\n   * Remove all callbacks (reset observer collection)\n   */\n  unobserveAll () {\n    this.observers = {}\n  }\n\n  /**\n   * Watch for any new element\n   * @return {Promise} Resolves with the next value added to observed array\n   */\n  next () {\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        this.unobserve(id)\n        return resolve({\n          value: value,\n          state: state,\n          count: 1\n        })\n      })\n    })\n  }\n\n  /**\n   * Look for a specific element (optionally up to limit or with iterator)\n   * @param  {Mixed} needle        The element to find (e.g. [username, message])\n   * @param  {Int} [limit]           Stop observing and resolve when reached\n   * @param  {Function} [iterator] Run with every push\n   * @return {Promise}             Resolves with result attributes\n   */\n  find (needle, ...args) {\n    let count = 0\n    let limit = _.isInteger(args[0]) ? args.shift() : false\n    let iterator = _.isFunction(args[0]) ? args.shift() : false\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        if (iterator) iterator(value)\n        count++\n        let found = _.isEqual(needle, value)\n        let maxed = (count === limit)\n        if (found || maxed) {\n          this.unobserve(id)\n          if (found) {\n            return resolve({\n              value: value,\n              state: state,\n              count: count\n            })\n          }\n          if (maxed) {\n            return resolve({\n              value: null,\n              state: state,\n              count: count\n            })\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Look for element matching pattern (optionally up to limit or with iterator)\n   * @param  {RegExp} regex        Pattern to match element (joined as string)\n   * @param  {Int} [limit]         Stop observing and resolve when reached\n   * @param  {Function} [iterator] Run with every push\n   * @return {Promise}             Resolves with result atts and match object\n  */\n  match (regex, ...args) {\n    let count = 0\n    let limit = _.isInteger(args[0]) ? args.shift() : false\n    let iterator = _.isFunction(args[0]) ? args.shift() : false\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        if (iterator) iterator(value)\n\n        count++\n        let match = value.join(' ').match(regex)\n        let maxed = (count === limit)\n        if (match || maxed) {\n          this.unobserve(id)\n          if (match) {\n            return resolve({\n              value: value,\n              state: state,\n              count: count,\n              match: match\n            })\n          }\n          if (maxed) {\n            return resolve({\n              value: null,\n              state: state,\n              count: count\n            })\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Observe all additions, up to limit or with iterator (must have either)\n   * @param  {Int} [limit]         Stop observing and resolve when reached\n   * @param  {Function} [iterator] Run with every push\n   * @return {Promise}             Resolves with result object attributes\n   */\n  all (...args) {\n    let count = 0\n    let limit = _.isInteger(args[0]) ? args.shift() : false\n    let iterator = _.isFunction(args[0]) ? args.shift() : false\n    if (!limit && !iterator) throw new Error('Must be called with either limit or iterator')\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        if (iterator) iterator(value)\n\n        count++\n        if (count === limit) {\n          this.unobserve(id)\n          return resolve({\n            value: value,\n            state: state,\n            count: count\n          })\n        }\n      })\n    })\n  }\n}\n"]}