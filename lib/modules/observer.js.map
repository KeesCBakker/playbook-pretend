{"version":3,"sources":["../../src/modules/observer.js"],"names":["constructor","arrayToObserve","observers","proxy","observed","Proxy","set","target","property","value","receiver","Number","isInteger","parseInt","map","cb","id","call","clone","get","observe","uniqueId","unobserve","index","unobserveAll","next","Promise","resolve","reject","state","count","find","needle","args","limit","shift","iterator","isFunction","found","isEqual","maxed","match","regex","join","all","Error"],"mappings":"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","file":"observer.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\n\n/**\n * Let tests observe additions to an array (of messages) via helper methods:\n * - `.next` - Watch for the next new element\n * - `.find` - Fidn a specific element\n * - `.match` - Find element matching a pattern\n * - `.all` - Do something with every element\n *\n * Each return an object with result attributes:\n * - _value_ - the last observed value when conditions were met\n * - _state_ - the state of the observed when the conditions were met\n * - _count_ - the number of additions between first call and a result\n *\n * `find`, `match` and `all` accept a _limit_ (int) of additions to observe, as\n * well as an _iterator_ (function) to call with every addition.\n *\n * With `find` and `match`, if limit is reached before main condition met\n * _value_ will be null\n */\nexport default class {\n  /**\n   * Get observer for array (this.observed should replace the original)\n   * @param  {array} arrayToObserve Array to observe\n   * @return {Observer}             Observer containing observed array\n   */\n  constructor (arrayToObserve = null) {\n    this.observers = {}\n    if (arrayToObserve != null) this.proxy(arrayToObserve)\n  }\n\n  /**\n   * Proxy the array, call observers to when setting a value\n   * Callbacks are passed an array with 0: the value, 1: the current array state\n   * Applies only on setting an index (int), not propterties like length\n   * @param  {array} arrayToObserve Array to observe\n   * @return {array}                Observed (proxy) array\n   */\n  proxy (arrayToObserve) {\n    let observers = this.observers\n    this.observed = new Proxy(arrayToObserve, {\n      set: function (target, property, value, receiver) {\n        target[property] = value\n        if (Number.isInteger(parseInt(property))) {\n          _.map(observers, (cb, id) => {\n            cb.call(this, value, _.clone(target), id)\n          })\n        }\n        return true\n      }\n    })\n    return this.observed\n  }\n\n  /**\n   * Get the observed array\n   * @return {array} Observed (proxy) array\n   */\n  get () {\n    return this.observed\n  }\n\n  /**\n   * Add a callback to call with any addition to observed array\n   * @param  {Function} cb Callback, given new value as argument\n   * @return {string}      ID of callback in observer collection (for removing)\n   */\n  observe (cb) {\n    let id = _.uniqueId('observer_')\n    this.observers[id] = cb\n    return id\n  }\n\n  /**\n   * Remove a callback from observer collection\n   * @param  {string} index ID of callback to remove\n   */\n  unobserve (index) {\n    if (index in this.observers) delete this.observers[index]\n  }\n\n  /**\n   * Remove all callbacks (reset observer collection)\n   */\n  unobserveAll () {\n    this.observers = {}\n  }\n\n  /**\n   * Watch for any new element\n   * @return {Promise} Resolves with the next value added to observed array\n   */\n  next () {\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        this.unobserve(id)\n        return resolve({\n          value: value,\n          state: state,\n          count: 1\n        })\n      })\n    })\n  }\n\n  /**\n   * Look for a specific element (optionally up to limit or with iterator)\n   * @param  {Mixed} needle        The element to find (e.g. [username, message])\n   * @param  {Int} [limit]           Stop observing and resolve when reached\n   * @param  {Function} [iterator] Run with every push\n   * @return {Promise}             Resolves with result attributes\n   */\n  find (needle, ...args) {\n    let count = 0\n    let limit = _.isInteger(args[0]) ? args.shift() : false\n    let iterator = _.isFunction(args[0]) ? args.shift() : false\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        if (iterator) iterator(value)\n        count++\n        let found = _.isEqual(needle, value)\n        let maxed = (count === limit)\n        if (found || maxed) {\n          this.unobserve(id)\n          if (found) {\n            return resolve({\n              value: value,\n              state: state,\n              count: count\n            })\n          }\n          if (maxed) {\n            return resolve({\n              value: null,\n              state: state,\n              count: count\n            })\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Look for element matching pattern (optionally up to limit or with iterator)\n   * @param  {RegExp} regex        Pattern to match element (joined as string)\n   * @param  {Int} [limit]         Stop observing and resolve when reached\n   * @param  {Function} [iterator] Run with every push\n   * @return {Promise}             Resolves with result atts and match object\n  */\n  match (regex, ...args) {\n    let count = 0\n    let limit = _.isInteger(args[0]) ? args.shift() : false\n    let iterator = _.isFunction(args[0]) ? args.shift() : false\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        if (iterator) iterator(value)\n\n        count++\n        let match = value.join(' ').match(regex)\n        let maxed = (count === limit)\n        if (match || maxed) {\n          this.unobserve(id)\n          if (match) {\n            return resolve({\n              value: value,\n              state: state,\n              count: count,\n              match: match\n            })\n          }\n          if (maxed) {\n            return resolve({\n              value: null,\n              state: state,\n              count: count\n            })\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Observe all additions, up to limit or with iterator (must have either)\n   * @param  {Int} [limit]         Stop observing and resolve when reached\n   * @param  {Function} [iterator] Run with every push\n   * @return {Promise}             Resolves with result object attributes\n   */\n  all (...args) {\n    let count = 0\n    let limit = _.isInteger(args[0]) ? args.shift() : false\n    let iterator = _.isFunction(args[0]) ? args.shift() : false\n    if (!limit && !iterator) throw new Error('Must be called with either limit or iterator')\n    return new Promise((resolve, reject) => {\n      this.observe((value, state, id) => {\n        if (iterator) iterator(value)\n\n        count++\n        if (count === limit) {\n          this.unobserve(id)\n          return resolve({\n            value: value,\n            state: state,\n            count: count\n          })\n        }\n      })\n    })\n  }\n}\n"]}